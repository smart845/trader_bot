
import requests
import pandas as pd
import numpy as np
import ta
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class AdvancedCryptoAnalyzer:
    def __init__(self):
        self.indicators = {}
        
    def get_binance_data(self, symbol: str, interval: str = '1h', limit: int = 500):
        """Получение данных с Binance"""
        url = "https://api.binance.com/api/v3/klines"
        params = {'symbol': symbol, 'interval': interval, 'limit': limit}
        data = requests.get(url, params=params).json()
        
        df = pd.DataFrame(data, columns=[
            'open_time', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_volume', 'trades', 'taker_buy_base',
            'taker_buy_quote', 'ignore'
        ])
        
        # Конвертация типов
        numeric_columns = ['open', 'high', 'low', 'close', 'volume', 'quote_volume']
        for col in numeric_columns:
            df[col] = pd.to_numeric(df[col])
            
        df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
        return df

    def get_funding_rate(self, symbol: str):
        """Получение фандинг рейта"""
        try:
            url = "https://fapi.binance.com/fapi/v1/premiumIndex"
            params = {'symbol': symbol}
            data = requests.get(url, params=params).json()
            return float(data.get('lastFundingRate', 0))
        except:
            return 0

    def get_open_interest(self, symbol: str):
        """Получение открытого интереса"""
        try:
            url = "https://fapi.binance.com/fapi/v1/openInterest"
            params = {'symbol': symbol}
            data = requests.get(url, params=params).json()
            return float(data.get('openInterest', 0))
        except:
            return 0

    def calculate_all_indicators(self, df):
        """Расчет всех возможных индикаторов"""
        df = df.copy()
        
        # === ТРЕНДОВЫЕ ИНДИКАТОРЫ ===
        # SMA
        for period in [5, 10, 20, 50, 100, 200]:
            df[f'sma_{period}'] = ta.trend.SMAIndicator(df['close'], window=period).sma_indicator()
        
        # EMA
        for period in [5, 10, 20, 50, 100]:
            df[f'ema_{period}'] = ta.trend.EMAIndicator(df['close'], window=period).ema_indicator()
        
        # WMA
        df['wma_20'] = ta.trend.WMAIndicator(df['close'], window=20).wma()
        
        # MACD
        macd = ta.trend.MACD(df['close'])
        df['macd'] = macd.macd()
        df['macd_signal'] = macd.macd_signal()
        df['macd_histogram'] = macd.macd_diff()
        
        # Parabolic SAR
        df['psar'] = ta.trend.PSARIndicator(df['high'], df['low'], df['close']).psar()
        
        # ADX
        df['adx'] = ta.trend.ADXIndicator(df['high'], df['low'], df['close']).adx()
        df['adx_neg'] = ta.trend.ADXIndicator(df['high'], df['low'], df['close']).adx_neg()
        df['adx_pos'] = ta.trend.ADXIndicator(df['high'], df['low'], df['close']).adx_pos()
        
        # Ichimoku Cloud
        ichimoku = ta.trend.IchimokuIndicator(df['high'], df['low'])
        df['ichimoku_a'] = ichimoku.ichimoku_a()
        df['ichimoku_b'] = ichimoku.ichimoku_b()
        df['ichimoku_base'] = ichimoku.ichimoku_base_line()
        df['ichimoku_conversion'] = ichimoku.ichimoku_conversion_line()
        
        # TRIX
        df['trix'] = ta.trend.TRIXIndicator(df['close']).trix()
        
        # Mass Index
        df['mass_index'] = ta.trend.MassIndex(df['high'], df['low']).mass_index()
        
        # CCI
        df['cci'] = ta.trend.CCIIndicator(df['high'], df['low'], df['close']).cci()
        
        # DPO
        df['dpo'] = ta.trend.DPOIndicator(df['close']).dpo()
        
        # KST
        df['kst'] = ta.trend.KSTIndicator(df['close']).kst()
        df['kst_signal'] = ta.trend.KSTIndicator(df['close']).kst_sig()
        
        # Aroon
        aroon = ta.trend.AroonIndicator(df['high'], df['low'])
        df['aroon_up'] = aroon.aroon_up()
        df['aroon_down'] = aroon.aroon_down()
        df['aroon_oscillator'] = aroon.aroon_indicator()

        # === МОМЕНТУМ ИНДИКАТОРЫ ===
        # RSI
        for period in [6, 14, 21]:
            df[f'rsi_{period}'] = ta.momentum.RSIIndicator(df['close'], window=period).rsi()
        
        # Stochastic
        stoch = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close'])
        df['stoch_k'] = stoch.stoch()
        df['stoch_d'] = stoch.stoch_signal()
        
        # Williams %R
        df['williams_r'] = ta.momentum.WilliamsRIndicator(df['high'], df['low'], df['close']).williams_r()
        
        # Awesome Oscillator
        df['ao'] = ta.momentum.AwesomeOscillatorIndicator(df['high'], df['low']).awesome_oscillator()
        
        # Kaufman Adaptive Moving Average
        df['kama'] = ta.momentum.KAMAIndicator(df['close']).kama()
        
        # Rate of Change (ROC)
        df['roc'] = ta.momentum.ROCIndicator(df['close']).roc()
        
        # True Strength Index (TSI)
        df['tsi'] = ta.momentum.TSIIndicator(df['close']).tsi()
        
        # Ultimate Oscillator
        df['uo'] = ta.momentum.UltimateOscillator(df['high'], df['low'], df['close']).ultimate_oscillator()
        
        # === ВОЛАТИЛЬНОСТЬ ===
        # Bollinger Bands
        bollinger = ta.volatility.BollingerBands(df['close'])
        df['bb_upper'] = bollinger.bollinger_hband()
        df['bb_lower'] = bollinger.bollinger_lband()
        df['bb_middle'] = bollinger.bollinger_mavg()
        df['bb_width'] = (df['bb_upper'] - df['bb_lower']) / df['bb_middle']
        
        # ATR
        df['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()
        
        # Keltner Channel
        keltner = ta.volatility.KeltnerChannel(df['high'], df['low'], df['close'])
        df['kc_upper'] = keltner.keltner_channel_hband()
        df['kc_lower'] = keltner.keltner_channel_lband()
        df['kc_middle'] = keltner.keltner_channel_mband()
        
        # Donchian Channel
        donchian = ta.volatility.DonchianChannel(df['high'], df['low'], df['close'])
        df['dc_upper'] = donchian.donchian_channel_hband()
        df['dc_lower'] = donchian.donchian_channel_lband()
        df['dc_middle'] = donchian.donchian_channel_mband()
        
        # === ОБЪЕМНЫЕ ИНДИКАТОРЫ ===
        # OBV
        df['obv'] = ta.volume.OnBalanceVolumeIndicator(df['close'], df['volume']).on_balance_volume()
        
        # Volume Weighted Average Price
        df['vwap'] = ta.volume.VolumeWeightedAveragePrice(df['high'], df['low'], df['close'], df['volume']).volume_weighted_average_price()
        
        # Money Flow Index
        df['mfi'] = ta.volume.MFIIndicator(df['high'], df['low'], df['close'], df['volume']).money_flow_index()
        
        # Accumulation/Distribution Line
        df['adl'] = ta.volume.AccDistIndexIndicator(df['high'], df['low'], df['close'], df['volume']).acc_dist_index()
        
        # Chaikin Money Flow
        df['cmf'] = ta.volume.ChaikinMoneyFlowIndicator(df['high'], df['low'], df['close'], df['volume']).chaikin_money_flow()
        
        # Volume Price Trend
        df['vpt'] = ta.volume.VolumePriceTrendIndicator(df['close'], df['volume']).volume_price_trend()
        
        # Negative Volume Index
        df['nvi'] = ta.volume.NegativeVolumeIndexIndicator(df['close'], df['volume']).negative_volume_index()
        
        # === КАСТОМНЫЕ РАСЧЕТЫ ===
        # Delta (разница между покупками и продажами)
        df['taker_buy_volume'] = pd.to_numeric(df['taker_buy_quote'])
        df['taker_sell_volume'] = pd.to_numeric(df['quote_volume']) - df['taker_buy_volume']
        df['volume_delta'] = df['taker_buy_volume'] - df['taker_sell_volume']
        df['volume_delta_ratio'] = df['volume_delta'] / df['quote_volume']
        
        # Price-Volume Trend
        df['pvt'] = (df['volume_delta'] / df['volume'].rolling(20).mean()) * df['close'].pct_change()
        
        # Support/Resistance Levels
        df['resistance'] = df['high'].rolling(20).max()
        df['support'] = df['low'].rolling(20).min()
        
        # Fibonacci Levels
        high_20 = df['high'].rolling(20).max()
        low_20 = df['low'].rolling(20).min()
        diff = high_20 - low_20
        df['fib_236'] = high_20 - diff * 0.236
        df['fib_382'] = high_20 - diff * 0.382
        df['fib_500'] = high_20 - diff * 0.5
        df['fib_618'] = high_20 - diff * 0.618
        df['fib_786'] = high_20 - diff * 0.786
        
        # Pivot Points
        df['pivot'] = (df['high'].shift(1) + df['low'].shift(1) + df['close'].shift(1)) / 3
        df['pivot_r1'] = 2 * df['pivot'] - df['low'].shift(1)
        df['pivot_s1'] = 2 * df['pivot'] - df['high'].shift(1)
        
        return df

    def calculate_market_structure(self, df):
        """Анализ рыночной структуры"""
        latest = df.iloc[-1]
        
        # Определение тренда
        trend_short = "BULL" if latest['close'] > latest['ema_20'] else "BEAR"
        trend_medium = "BULL" if latest['close'] > latest['ema_50'] else "BEAR"
        trend_long = "BULL" if latest['close'] > latest['ema_200'] else "BEAR"
        
        # Уровни перекупленности/перепроданности
        overbought = latest['rsi_14'] > 70
        oversold = latest['rsi_14'] < 30
        
        # Сигналы индикаторов
        signals = {
            'macd_bullish': latest['macd'] > latest['macd_signal'],
            'rsi_bullish': latest['rsi_14'] > 50,
            'stoch_bullish': latest['stoch_k'] > latest['stoch_d'],
            'above_vwap': latest['close'] > latest['vwap'],
            'volume_confirm': latest['volume'] > latest['volume'].rolling(20).mean(),
            'adx_strong': latest['adx'] > 25
        }
        
        bull_signals = sum(signals.values())
        total_signals = len(signals)
        
        return {
            'trend_short': trend_short,
            'trend_medium': trend_medium,
            'trend_long': trend_long,
            'overbought': overbought,
            'oversold': oversold,
            'bullish_score': bull_signals / total_signals,
            'signals': signals
        }

    def calculate_entry_points(self, df, market_structure):
        """Расчет точек входа и выхода"""
        latest = df.iloc[-1]
        current_price = latest['close']
        
        # Базовые уровни на основе волатильности
        atr = latest['atr']
        atr_multiplier = 2
        
        if market_structure['bullish_score'] > 0.6 and not market_structure['overbought']:
            # LONG сигнал
            entry = current_price * 0.998  # Немного ниже текущей цены
            stop_loss = min(latest['support'], latest['fib_618'], entry - atr * atr_multiplier)
            take_profit_1 = entry + atr * 1
            take_profit_2 = entry + atr * 2
            take_profit_3 = latest['resistance']
            
            direction = "LONG"
            
        elif market_structure['bullish_score'] < 0.4 and not market_structure['oversold']:
            # SHORT сигнал
            entry = current_price * 1.002  # Немного выше текущей цены
            stop_loss = max(latest['resistance'], latest['fib_382'], entry + atr * atr_multiplier)
            take_profit_1 = entry - atr * 1
            take_profit_2 = entry - atr * 2
            take_profit_3 = latest['support']
            
            direction = "SHORT"
        else:
            # Нет четкого сигнала
            return {
                'direction': 'HOLD',
                'entry': None,
                'stop_loss': None,
                'take_profits': [],
                'confidence': market_structure['bullish_score']
            }
        
        # Расчет риска и доходности
        risk = abs(entry - stop_loss)
        reward_1 = abs(take_profit_1 - entry)
        reward_2 = abs(take_profit_2 - entry)
        reward_3 = abs(take_profit_3 - entry)
        
        risk_reward_1 = reward_1 / risk if risk > 0 else 0
        risk_reward_2 = reward_2 / risk if risk > 0 else 0
        risk_reward_3 = reward_3 / risk if risk > 0 else 0
        
        return {
            'direction': direction,
            'entry': round(entry, 4),
            'stop_loss': round(stop_loss, 4),
            'take_profits': [
                {'level': round(take_profit_1, 4), 'rr_ratio': round(risk_reward_1, 2)},
                {'level': round(take_profit_2, 4), 'rr_ratio': round(risk_reward_2, 2)},
                {'level': round(take_profit_3, 4), 'rr_ratio': round(risk_reward_3, 2)}
            ],
            'risk_per_trade': f"{round(risk/current_price*100, 2)}%",
            'confidence': round(market_structure['bullish_score'], 3)
        }

    def analyze_coin(self, coin: str):
        """Полный анализ монеты"""
        symbol = f"{coin}USDT"
        
        try:
            # Получение данных
            df = self.get_binance_data(symbol)
            if df.empty:
                return {"error": "Не удалось получить данные"}
            
            # Расчет индикаторов
            df = self.calculate_all_indicators(df)
            
            # Дополнительные метрики
            funding_rate = self.get_funding_rate(symbol)
            open_interest = self.get_open_interest(symbol)
            
            # Анализ структуры
            market_structure = self.calculate_market_structure(df)
            
            # Торговые уровни
            trading_levels = self.calculate_entry_points(df, market_structure)
            
            # Сбор всех метрик
            latest = df.iloc[-1]
            
            result = {
                'coin': coin,
                'current_price': round(latest['close'], 4),
                'price_change_24h': round((latest['close'] - df.iloc[-24]['close']) / df.iloc[-24]['close'] * 100, 2),
                'volume_24h': round(latest['quote_volume'], 2),
                'market_metrics': {
                    'funding_rate': round(funding_rate * 100, 4),
                    'open_interest': open_interest,
                    'volume_delta': round(latest['volume_delta_ratio'] * 100, 2),
                    'taker_buy_ratio': round(latest['taker_buy_volume'] / latest['quote_volume'] * 100, 2)
                },
                'market_structure': market_structure,
                'key_indicators': {
                    'rsi_14': round(latest['rsi_14'], 2),
                    'macd': round(latest['macd'], 4),
                    'macd_signal': round(latest['macd_signal'], 4),
                    'stoch_k': round(latest['stoch_k'], 2),
                    'stoch_d': round(latest['stoch_d'], 2),
                    'adx': round(latest['adx'], 2),
                    'atr': round(latest['atr'], 4),
                    'bb_width': round(latest['bb_width'] * 100, 2),
                    'vwap': round(latest['vwap'], 4),
                    'obv_trend': 'BULL' if latest['obv'] > df['obv'].rolling(20).mean().iloc[-1] else 'BEAR'
                },
                'trading_recommendation': trading_levels,
                'support_resistance': {
                    'support': round(latest['support'], 4),
                    'resistance': round(latest['resistance'], 4),
                    'fib_382': round(latest['fib_382'], 4),
                    'fib_618': round(latest['fib_618'], 4)
                },
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            
            return result
            
        except Exception as e:
            return {"error": f"Ошибка анализа: {str(e)}"}

# Использование
def main():
    analyzer = AdvancedCryptoAnalyzer()
    
    # Анализ конкретной монеты
    coin = input("Введите название монеты (например BTC): ").upper()
    result = analyzer.analyze_coin(coin)
    
    # Красивый вывод
    print(f"\n{'='*60}")
    print(f"АНАЛИЗ {coin}/USDT")
    print(f"{'='*60}")
    print(f"Текущая цена: ${result['current_price']}")
    print(f"Изменение за 24ч: {result['price_change_24h']}%")
    print(f"Объем 24ч: ${result['volume_24h']:,.0f}")
    
    print(f"\n--- РЫНОЧНЫЕ МЕТРИКИ ---")
    metrics = result['market_metrics']
    print(f"Фандинг рейт: {metrics['funding_rate']}%")
    print(f"Открытый интерес: {metrics['open_interest']:,.0f}")
    print(f"Дельта объема: {metrics['volume_delta']}%")
    print(f"Соотношение покупателей: {metrics['taker_buy_ratio']}%")
    
    print(f"\n--- КЛЮЧЕВЫЕ ИНДИКАТОРЫ ---")
    indicators = result['key_indicators']
    print(f"RSI 14: {indicators['rsi_14']} {'(ПЕРЕКУП)' if indicators['rsi_14'] > 70 else '(ПЕРЕПРОДАН)' if indicators['rsi_14'] < 30 else ''}")
    print(f"MACD: {indicators['macd']} | Сигнал: {indicators['macd_signal']}")
    print(f"Stoch: K={indicators['stoch_k']}, D={indicators['stoch_d']}")
    print(f"ADX: {indicators['adx']} {'(СИЛЬНЫЙ ТРЕНД)' if indicators['adx'] > 25 else ''}")
    print(f"ATR: {indicators['atr']} | Ширина BB: {indicators['bb_width']}%")
    print(f"VWAP: {indicators['vwap']} | OBV: {indicators['obv_trend']}")
    
    print(f"\n--- РЫНОЧНАЯ СТРУКТУРА ---")
    structure = result['market_structure']
    print(f"Тренд (К/С/Д): {structure['trend_short']}/{structure['trend_medium']}/{structure['trend_long']}")
    print(f"Бычий счет: {structure['bullish_score'] * 100}%")
    print(f"Состояние: {'ПЕРЕКУП' if structure['overbought'] else 'ПЕРЕПРОДАН' if structure['oversold'] else 'НЕЙТРАЛЬНО'}")
    
    print(f"\n--- ТОРГОВЫЕ РЕКОМЕНДАЦИИ ---")
    rec = result['trading_recommendation']
    print(f"Направление: {rec['direction']}")
    if rec['direction'] != 'HOLD':
        print(f"Точка входа: ${rec['entry']}")
        print(f"Стоп-лосс: ${rec['stop_loss']} ({rec['risk_per_trade']})")
        print(f"Тейк-профиты:")
        for i, tp in enumerate(rec['take_profits'], 1):
            print(f"  TP{i}: ${tp['level']} (R:R {tp['rr_ratio']})")
    print(f"Уверенность: {rec['confidence'] * 100}%")
    
    print(f"\n--- УРОВНИ ПОДДЕРЖКИ/СОПРОТИВЛЕНИЯ ---")
    levels = result['support_resistance']
    print(f"Поддержка: ${levels['support']}")
    print(f"Сопротивление: ${levels['resistance']}")
    print(f"Фибо 38.2%: ${levels['fib_382']}")
    print(f"Фибо 61.8%: ${levels['fib_618']}")

if __name__ == "__main__":
    main()